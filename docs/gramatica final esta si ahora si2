<Inicial> ::= <ListaClasesEInterfaces> eof

<ListaClasesEInterfaces> ::= <ModificadorOpcional> <ListaClasesEInterfaces2> | 
<ListaClasesEInterfaces2> ::= <Clase> <ListaClasesEInterfaces> | <Interfaz> <ListaClasesEInterfaces>  

<Clase> ::= class idClase <GenericidadOpcional> <HerenciaOpcional> { <ListaMiembros> }
<Interfaz> ::= interface idClase <GenericidadOpcional> <ExtendsOpcional> { <ListaMiembrosInterfaz> }

<ModificadorOpcional> ::= abstract | static | final | 
<Modificador> ::= abstract | static | final
<VisibilidadOpcional> ::= public | private | 
<PrivateOpcional> ::= private | 

<HerenciaOpcional> ::= extends idClase <GenericidadOpcional>| implements idClase <GenericidadOpcional>| 
<ExtendsOpcional> ::= extends idClase <GenericidadOpcional>| 

<GenericidadODiamanteOpcional> ::= < <IdClaseOpcional> > | 
<IdClaseOpcional> ::= idClase | 

<GenericidadOpcional> ::= <  idClase  > | 

<ListaMiembros> ::= <PrivateOpcional> <AtributoOMetodo> <ListaMiembros> | 
<ListaMIembros> ::= public <Miembro> <ListaMiembros> 
<ListaMiembrosInterfaz> ::= <VisibilidadOpcional> <MiembroInterfaz> <ListaMiembrosInterfaz> | 

<Miembro> ::= <TipoPrimitivo> idMetVar <CierreAtributoMetodo> | <Modificador> <TipoMetodo> idMetVar <ArgsFormalesYBloqueOpcional> 
<Miembro> ::= void idMetVar <ArgsFormalesYBloqueOpcional> | idClase <ConstructorUOtroMiembro>
<MiembroInterfaz> ::= <Tipo> idMetVar = <Expresion> ; | <Modificador> <TipoMetodo> idMetVar <ArgsFormalesYBloqueOpcional>  
<MiembroInterfaz> ::= void idMetVar <ArgsFormalesYBloqueOpcional>

<CierreAtributoMetodo> ::= <AsignacionOpcional> ; | <ArgsFormalesYBloqueOpcional>
<ArgsFormalesYBloqueOpcional> ::= <ArgsFormales> <BloqueOpcional>

<Atributo> ::= <Tipo> idMetVar <AsignacionOpcional> ;										### ahora se puede inicializar el atributo
<AsignacionOpcional> ::=   =   <Expresion> | 
<AtributoInicializado> ::= <Tipo> idMetVar = <Expresion> ;

<AtributoOMetodo> ::= <Tipo> idMetVar <CierreAtributoMetodo> 
<AtributoOMetodo> ::= <Modificador> <TipoMetodo> idMetVar <ArgsFormalesYBloqueOpcional> | void idMetVar <ArgsFormalesYBloqueOpcional>

<ConstructorUOtroMiembro> ::= <ArgsFormales> <Bloque> | idMetVar <CierreAtributoMetodo>

<TipoMetodo> ::= <Tipo> | void

<Tipo> ::= <TipoPrimitivo> | idClase <GenericidadOpcional>

<TipoPrimitivo> ::= boolean | char | int

<ArgsFormales> ::= ( <ListaArgsFormalesOpcional> )


<ListaArgsFormalesOpcional> ::= <ListaArgsFormales> | 

<ListaArgsFormales> ::= <ArgFormal> <ListaArgsFormales2>
<ListaArgsFormales2> ::= , <ArgFormal> <ListaArgsFormales2> | 									#####################3

<ArgFormal> ::= <Tipo> idMetVar

<BloqueOpcional> ::= <Bloque> | ;

<Bloque> ::= { <ListaSentencias> }

<ListaSentencias> ::= <Sentencia> <ListaSentencias> | 

<Sentencia> ::= ;
<Sentencia> ::= <AsignacionLlamadaOVarLocal> ;																	###VarLocal y AsignacionOLlamada tienen conflicto ya que ambos tinene idClase en
<Sentencia> ::= <Return> ;																			###primeros, varLocal en <Tipo> y AsignacionOLlamada en expresion -> LlamadaMetodoEstatico
<Sentencia> ::= <If>
<Sentencia> ::= <While>
<Sentencia> ::= <Bloque>
<Sentencia> ::= <For>

<AsignacionLlamadaOVarLocal> ::= <VarLocalConVar>
<AsignacionLlamadaOVarLocal> ::= <VarLocalConTipoPrimitivo> 
<AsignacionLlamadaOVarLocal> ::= idClase <MetodoEstativoOVarLocal> 
<AsignacionLlamadaOVarLocal> ::= <ExpresionSinLlamadaMetodoEstatico>

<MetodoEstativoOVarLocal> ::=  . idMetVar <ArgsActuales> <Referencia2> <ExpresionCompuesta2> <Expresion2>
<MetodoEstativoOVarLocal> ::= <GenericidadOpcional> idMetVar <DeclaracionMultiple> <AsignacionOpcional>

<ExpresionSinLlamadaMetodoEstatico> ::= <ExpresionCompuestaSinLLamadaMetodoEstatico> <Expresion2>

<ExpresionCompuestaSinLLamadaMetodoEstatico> ::= <ExpresionBasica> <ExpresionCompuesta2>   

<VarLocalConVar> ::= var idMetVar = <Expresion> 
<VarLocalConTipoPrimistivo> ::= <TipoPrimitivo> idMetVar <DeclaracionMultiple> <AsignacionOpcional>

<For> ::= for ( <For2> <CondicionFor ) <Sentencia>	
<For2> ::= 	<VarLocalConVar> | <TipoPrimitivo> idMetVar <DeclaracionMultiple> = <Expresion> 
<For2> ::=  idClase <MetodoEstaticoOVarLocalInicializada> | <ExpresionSinLlamadaMetodoEstatico> | 
<CondicionFor> ::= ; <ExpresionCompuestaOpcional> ; <ExpresionOpcional> | : <Expresion>

<MetodoEstaticoOVarLocalInicializada> ::= . idMetVar <ArgsActuales> <Referencia2> <ExpresionCompuesta2>  <Expresion2>
<MetodoEstaticoOVarLocalInicializada> ::= <GerenicidadOpcional> idMetVar <DeclaracionMultiple> = <Expresion>

<AsignacionOLlamada> ::= <Expresion>

<VarLocal> ::= var idMetVar = <Expression>  | <Tipo> idMetVar <DeclaracionMultiple> <AsignacionOpcional> 
<DeclaracionMultiple> ::= , idMetVar <DeclaracionMultiple> | 

<Return> ::= return <ExpresionOpcional>

<ExpresionOpcional> ::= <Expresion> | 

<If> ::= if ( <Expresion> ) <Sentencia> <SentenciaElse>
<SentenciaElse> ::= else <Sentencia> | 

<While> ::= while ( <Expresion> ) <Sentencia>

<Expresion> ::= <ExpresionCompuesta> <Expresion2>
<Expresion2> ::= <OperadorAsignacion> <ExpresionCompuesta> <OperadorTernarioOpcional> | <OperadorTernarioOpcional>

<OperadorTernarioOpcional> ::=  ? <Expresion> : <ExpresionCompuesta> <OperadorTernarioOpcional> | 

<OperadorAsignacion> ::= = | += | -=

<ExpresionCompuesta> ::= <ExpresionBasica> <ExpresionCompuesta2> 
<ExpresionCompuesta> ::= <LlamadaMetodoEstatico> <Referencia2> <ExpresionCompuesta2>
<ExpresionCompuesta2> ::= <OperadorBinario> <ExpresionBasica> <ExpresionCompuesta> | 


<OperadorBinario> ::= || | && | == | != | < | > | <= | >= | + | - | * | / | %

<ExpresionBasica> ::= <OperadorUnario> <Operando>
<ExpresionBasica> ::= <Operando>

<OperadorUnario> ::= + | ++ | âˆ’ | âˆ’âˆ’ | !

<Operando> ::= <Primitivo>
<Operando> ::= <Referencia>

<Primitivo> ::= true | false | intLiteral | charLiteral | null

<Referencia> ::= <Primario> <Referencia2>
<Referencia2> ::= <VarMetodoEncadenado> <Referencia2> | 													

<Primario> ::= this
<Primario> ::= stringLiteral
<Primario> ::= <AccesoVarLlamadaMetodo>
<Primario> ::= <LlamadaConstructor>
<Primario> ::= <ExpresionParentizada>

<AccesoVarLlamadaMetodo> ::= idMetVar <ArgsActualesOpcional>

<ArgsActualesOpcional> ::= <ArgsActuales> | 

<LlamadaConstructor> ::= new idClase <GenericidadODiamanteOpcional> <ArgsActuales>

<ExpresionParentizada> ::= ( <Expresion> )

<LlamadaMetodoEstatico> ::= idClase . idMetVar <ArgsActuales>

<ArgsActuales> ::= ( <ListaExpsOpcional> )

<ListaExpsOpcional> ::= <ListaExps> | 

<ListaExps> ::= <Expresion> <ListaExps2>
<ListaExps2> ::= , <Expresion> <ListaExps2> | 

<VarMetodoEncadenado> ::= . idMetVar <ArgsActualesOpcional>











________________POSIBLE SOLUCION AL TEMITA DEL CONSTRUCTOR Y LA VISIBILIDAD________________________

<PrivateOpcional> ::= private | 

<ListaMiembros> ::= <PrivateOpcional> <AtributoOMetodo> <ListaMiembros> | 
<ListaMIembros> ::= public <Miembro> <ListaMiembros> 

<Miembro> ::= <TipoPrimitivo> idMetVar <CierreAtributoMetodo> | <Modificador> <TipoMetodo> idMetVar <ArgsFormalesYBloqueOpcional> 
<Miembro> ::= void idMetVar <ArgsFormalesYBloqueOpcional> | idClase <ConstructorUOtroMiembro>

<ConstructorUOtroMiembro> ::= <ArgsFormales> <Bloque> | idMetVar <CierreAtributoMetodo>

<AtributoOMetodo> ::= <Tipo> idMetVar <CierreAtributoMetodo> 
<AtributoOMetodo> ::= <Modificador> <TipoMetodo> idMetVar <ArgsFormalesYBloqueOpcional> | void idMetVar <ArgsFormalesYBloqueOpcional>

<Constructor> ::= idClase <ArgsFormales> <Bloque>

<CierreAtributoMetodo> ::= <AsignacionOpcional> ; | <ArgsFormalesYBloqueOpcional>
<ArgsFormalesYBloqueOpcional> ::= <ArgsFormales> <BloqueOpcional>